using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace NeoCortexApi.Utility
{

    /**
     * <p>
     * Allegory to the Python itertools.groupby. Objects of this class
     * take a list of inputs and a function to produce keys. The iterator
     * or foreach loop generates grouped return values based on the key
     * generated by the supplied function.<br>
     * For instance:<br>
     * <pre>
     * Given the list:
     * List<Integer> l = Arrays.asList(new Integer[] { 2, 4, 4, 5 });
     * and the function:
     * Function<Integer, Integer> lambda = x -> x * 3;
     * 
     * A GroupBy can be compose as such:
     * GroupBy<Integer, Integer> grouper = GroupBy.of(l, lambda);
     * 
     * ...then iterated over as such:
     * for(Pair<Integer, Integer> p : grouper) {
     *     System.out.println("Pair key: " + p.getKey() + ", pair value: " + p.getValue());
     * }
     * 
     * Outputs:
     * 
     * Pair key: 2, pair value: 6
     * Pair key: 4, pair value: 12
     * Pair key: 4, pair value: 12
     * Pair key: 5, pair value: 15
     * </p>
     * <p>
     * Notes: Read up on groupby here:
     *        https://docs.python.org/dev/library/itertools.html#itertools.groupby
     *        
     * </p>
     * @author cogmission
     *
     * @param <T>
     * @param <R>
     */
    public class GroupBy<T, R> : IEnumerator<KeyValuePair<T, R>?>
    {

        /** serial version */
        //private static readonly long serialVersionUID = 1L;

        private List<T> m_ElementList;
        private Func<T, R> m_Func;
        private IntGenerator m_IntegerGenerator;
        private KeyValuePair<T, R>? m_next;


        public KeyValuePair<T, R>? Current => this.m_next;

        object IEnumerator.Current => this.m_next;


        #region Constructors and Initialization


        /**
         * Constructs a new {@code GroupBy}
         * 
         * @param l     the {@link List} containing the items used as input to the
         *              key generating function.     
         * @param fn    the {@link Function} to be used to generate the keys which describe
         *              the like contents of each grouping.
         */
        public GroupBy(List<T> l, Func<T, R> func)
        {
            this.m_ElementList = l;
            this.m_Func = func;
            this.m_IntegerGenerator = IntGenerator.of(0, m_ElementList.Count);

            if (m_IntegerGenerator.hasNext())
            {
                T t = m_ElementList[m_IntegerGenerator.next()];
                m_next = new KeyValuePair<T, R>(t, func(t));
            }
        }


        /**
         * Returns a new {@code GroupBy} composed from the specified list 
         * and key-generating {@link Function}
         * 
         * @param l     the {@link List} containing the items used as input to the
         *              key generating function.     
         * @param fn    the {@link Function} to be used to generate the keys which describe
         *              the like contents of each grouping.
         * @return
         */
        public static GroupBy<T, R> From(List<T> l, Func<T, R> fn)
        {
            return new GroupBy<T, R>(l, fn);
        }
        #endregion


        /**
         * {@inheritDoc}
         */
        // @Override
        public KeyValuePair<T, R> peek()
        {
            return m_next.Value;
        }

        /**
         * {@inheritDoc}
         */
        // @Override
        public bool hasNext()
        {
            return m_next != null;
        }

        /**
         * {@inheritDoc}
         */
        //@Override
        public KeyValuePair<T, R>? next()
        {
            // T t = range.hasNext() ? iter[range.next()] : null;
            //m_next = t != null ? new KeyValuePair<T, R>(t, fn(t)) : null;

            return MoveNext() ? m_next : null;
        }

        public bool MoveNext()
        {
            KeyValuePair<T, R>? ret = m_next;

            if (m_IntegerGenerator.hasNext())
            {
                T t = m_ElementList[m_IntegerGenerator.next()];
                m_next = new KeyValuePair<T, R>(t, m_Func(t));
                return true;
            }
            else
            {
                m_next = null;
                return false;
            }
        }


        public void Reset()
        {
            m_IntegerGenerator.reset();
            m_IntegerGenerator.next();
            m_next = null;
        }

        public void Dispose()
        {
           
        }
    }

}
